------------------------------------------------------- 
Stashing changes -> git stash (temporary storage area)
-------------------------------------------------------

What is the problem that git stashing or git stash solves? 

example:
- we're working on a repo and I'm on the master branch. I've got a file I'm working on.(cat.py)
- So I'm doing a whole bunch of work and then I make some commits and then I switch over to a new branch. 
I just make that new branch. I switch to it, it's called puppy and I do some more work over here.
- And then I have some uncommitted work on this puppy branch. So I never committed this dog file, for example
- And then I need to switch back to master. I don't know why, something's wrong, I need to switch back quickly.
-------------------------------------------------------
- What happens if I have a file or a hundred files, if I have uncommitted changes on one branch and I switch to another branch? 
There are 2 options:
1. My changes come with me to the destination branch. (if there are no conflicts)
2. Git won´t let me switch if it detects potential conflicts.
-------------------------------------------------------
So, what is stashing? Stashing is a way to save your changes temporarily without committing them.
- It allows you to switch branches or work on something else without losing your changes.
- You can think of it as a temporary storage area for your changes.

So, when you stash your changes, Git takes the changes in your working directory and saves them in a special area called the stash.
- This stash is like a stack of changes that you can apply later.
- You can have multiple stashes, and you can apply them in any order you want.

we can use git stash :
- to save our changes temporarily
- to switch branches without moving our changes to the new branch
- to apply our changes later
- to view the changes we have stashed
- to delete the stashes we no longer need
- to apply the changes from a specific stash
- to apply the changes from the most recent stash

-------------------------------------------------------
git stash save & git stash pop
-------------------------------------------------------

git stash -> at any point will take all uncommitted changes,(ANYTHING STAGED OR UNSTAGED), and it's going to stash them.

It kind of hides them away, but it remembers them and it reverts those changes in our working copy. 
So we don't see those changes anymore, but they're still available in that stash that we can come back and retrieve them.
So it saves those changes, does not make a commit. And then we could switch branches, just as a quick example.

git stash pop -> applies the most recent stash from the stash list to the working directory and removes it from the stash list.

So I can also use git stash to stash some changes and then maybe a little while later, 
reapply them to a different branch or to the same branch that I stashed them on.

git stash list -> show the list of stashes (it will show the stashes that are saved)

we can have multiple things in the stash but most frequently we just have one

WE CAN FIND CONFLICTS HERE TOO and we have to resolve them.
-------------------------------------------------------
So, if I have a stash and I try to pop it, and there are conflicts, it's the same process as before.
I have to go in and resolve the conflicts, and then I can add and commit those changes.

-------------------------------------------------------
git stash apply - (not too used)
-------------------------------------------------------

git stash apply -> stash and apply it in the same way that pop does EXCEPT

with apply the stash stays in the stash, the changes are still in the stash and we can apply them in multiple places 
versus with pop, our changes are removed from the stash after they're applied.

clean the stash: (later on)

-------------------------------------------------------
Working With Multiple Stashes
-------------------------------------------------------

git stash list - show the stashes that are saved

git stash list
stash@{0}: WIP on master: 049d078 Create index file
stash@{1}: WIP on master: c264051 Revert "Add file_size"
stash@{2}: WIP on master: 21d80a5 Add number to log

the lower the number, the more recent the stash.
most recent stash is stash@{0}, the second most recent is stash@{1} ...

git stash pop -> will apply and remove stash@{0}
git stash apply pop@{2} -> will apply and remove stash@{2}
git stash apply stash@{2} -> to apply that specific stash.

-------------------------------------------------------
Dropping & Clearing The Stash -> git stash drop <stash@{n}> & git stash clear
-------------------------------------------------------

git stash drop <stash@{n}> -> remove the specified stash from the stash list
git stash clear -> remove all stashes from the stash list

git stash show -> show the changes in the most recent stash
git stash show <stash@{n}> -> show the changes in the specified stash 

remember: 
git stash pop -> applies the most recent stash from the stash list to the working directory and removes it from the stash list.

-------------------------------------------------------
Undoing changes & Time travelling -> git checkout <commit_hash>
-------------------------------------------------------

- when we checkout an earlier commit, what we're doing is actually changing HEAD to refer to a commit.
git checkout <commit_hash> -> to view a previous commit 

git checkout 9e14873

Note: switching to '9e14873'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by switching back to a branch.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -c with the switch command.

HEAD is now at 9e14873 first addition in 04 file
HEAD detached at 9e14873
nothing to commit, working tree clean

git switch - -> went back to the branch I was on before if I do not remember the name of the branch.

So what is this detached head?
normally HEAD points to a particular branch reference.
Whatever branch you're on HEAD points to the branch reference and then the 
branch reference itself points to the tip of a branch, the most recent commit on a branch.

- HEAD usually refers to a particular branch reference. It does not refer to a commit.
- HEAD is referring to the branch that we're on and the branch reference points to a commit

refs/heads/master OR refs/heads/oldies -> they are references to the branches (they are pointers to the branches) <-

- now I'm in detached HEAD and HEAD is actually referring to a commit, the particular commit that I'm on
cat .git/HEAD - bb51809872529hdsfoip48578

-------------------------------------------------------
Re-Attaching Our Detached HEAD!
-------------------------------------------------------

We have back to our previous commit. You have a couple of options:
-------------------------------------------------------
1. Stay in detached HEAD to examine the contents of the old commit. View the files, etc
2. Leave and go back to the branch you were on. -> (git checkout master) 
	- WE WERE RE-ATTACHED (HEAD is now pointing to master and master is pointing to the latest commit)
3. Create a new branch from the commit you are on and switch to it. (git checkout -b <branch_name>) 
(you can now make and save changes, since HEAD is no longer detached)

git switch - -> went back to the branch I was on before if I do not remember the name of the branch.

-------------------------------------------------------
Referencing Commits Relative to HEAD
-------------------------------------------------------

git checkout HEAD~1 - go back one commit (it will go back one commit) parents
git checkout HEAD~2 - go back two commits (it will go back two commits) grandparents

git checkout HEAD~1 (1 commit back), if I do again HEAD~1, 
it will go back to the commit before that. (2 commits back from the starting point)

-------------------------------------------------------
Discarding Changes With -> git checkout
-------------------------------------------------------

WE ARE DISCARDING CHANGES OF FILES THAT HAVE ALREADY BEEN COMMITED,
OTHERWISE GIT WILL TELL YOU - error: pathspec 'aitor33.txt' did not match any file(s) known to git

We can use git checkout to discard changes from a file basically to revert back to whenever we previously committed.

now I am on the working directory and I have made some changes to the file.
if I don't want to commit that, if that's a mistake
- option 1 : manually delete the changes
- option 2 : git checkout HEAD <file> <file> - discard the changes in the working directory and revert to the last commit 
(HEAD is pointing to previous branch and previous branch is pointing to the last commit)
- option 3 : git checkout -- <file> <file> - discard the changes in the working directory

git clean -f filename.txt -> This removes the untracked file named filename.txt. (NEW FILE in the working directory)





-------------------------------------------------------
Un-Modifying With -> git restore
-------------------------------------------------------
- (git switch and git restore new commands due to the amount of confusion with git checkout) 

1. Discard changes that we've made in a repository since the last commit. (as we saw with git checkout)
->  git restore <file> - discard the changes in the working directory and revert to the last commit 
(we do not have to provide HEAD) ->  git checkout HEAD <file>
(HEAD is pointing to previous branch and previous branch is pointing to the last commit)

2. reference a particular commit and go back.
-> git restore --source HEAD~2 <file>
# ------------------------------------------------------------------------ 
# - I am going to loose the unstaged/uncommitted changes in the working directory and I am going to get the info in that commit back referring to HEAD~2
# -> BUT I am not going to change the HEAD pointer. (we are still on the same branch, on the last commit) (we hae not going back in time) (No detached HEAD or anything like that)
# -> BUT the file has been reverted to the state it was in at that commit. (has been modified)
# ------------------------------------------------------------------------
# and If I want to go back again to the last commit, I can do -> git restore <file> and it will go back to the last commit.
# and I will get the info where I came from. 
# -> (I can just restore one file to the last commit and I keep the other file as it was in HEAD~2)
# ------------------------------------------------------------------------
# example:
# we are in a repo with 2 files, and I have made 3 commits.
# now I am on the working directory and I have made some changes to one of the files.
# but I want to go back 2 commits and get the info in that commit back referring to HEAD~2
# git restore --source HEAD~2 <file1> <file2>
# now I want to go back again to the last commit but just for one file
# git restore <file1>
# and right know I have the file1 as it was in HEAD~2 and file2 as it was in HEAD
# ------------------------------------------------------------------------
# and maybe I could create a new branch from here and keep working on it.....
# ------------------------------------------------------------------------


-------------------------------------------------------
Un-Staging Changes With -> git restore		
-------------------------------------------------------

# Un-Staging Changes With Git Restore
# ********************************************************************************************************************
# if we made a mistake, we stage something it's going to be included in the next commit and then we decide, ah, we really don't want that.
# We can un stage it using 
# git restore --staged <file> - unstage the changes in the staging area and revert to the last commit (HEAD is pointing to previous branch and previous branch is pointing to the last commit)
# ------------------------------------------------------------------------
# git status - will give you some kind of help suggesting that you can use git restore to unstage the changes.
# ------------------------------------------------------------------------

-------------------------------------------------------
Undoing Commits With -> git reset		
-------------------------------------------------------

# Undoing Commits With Git Reset
# ********************************************************************************************************************
# The git reset command will reset a repository back to some particular commit.
# ------------------------------------------------------------------------
# So if we're working on, let's say the master branch and then I realized that the last three commits that I've made we're not supposed to be on the master branch.
# I screwed that up and I wanted to put them on a different branch and I want to remove them from master. 
# I can do that. I undo those commits using git reset. 
# ------------------------------------------------------------------------
# git log --oneline
# ------------------------------------------------------------------
# There are 2 different types of resets:
# 1. Regular Reset
# 2. Hard Reset
# ------------------------------------------------------------------------
# 1. Regular Reset (we are only telling git - get rid of the commits) - the history stops at that commit, but changes are still in the working directory. 
#  (we lose the commits. However many commits there were between head, all the way back to this commit)
# - git reset <commit_hash> - reset the repository to the specified commit (it will reset the repository to the specified commit)
# ------------------------------------------------------------------------
# Well, you might think those changes are gone but they're actually not. Those changes are still here. Doesn't that seem like they should be reset?
# -> No, because all that we did was perform a basic or a plain reset and that removed the commits but the changes are still in our working directory.
# ------------------------------------------------------------------------


# We lost those commits on the master branch but now I could take these changes with me and make a new branch,
# git switch -b badstuff
# git add .
# git commit -m "add bad stuff"
# ------------------------------------------------------------------------
# So I took those changes with me over to the new branch. I added and committed them on the new branch and then went back to master without those changes.
# git switch master
# ------------------------------------------------------------------------


# 2. Hard Reset
# ------------------------------------------------------------------------
# - git reset --hard <commit_hash> - reset the repository to the specified commit and discard all changes in the working directory (it will reset the repository to the specified commit and discard all changes in the working directory)
# ------------------------------------------------------------------------
# - git reset --hard 39c3f3b
# - git reset --hard HEAD~1 - reset the repository to the last commit and discard all changes in the working directory (it will reset the repository to the last commit and discard all changes in the working directory)
# ------------------------------------------------------------------------
# I could have created a new branch from an specific commit 'as a backup' and then I could have done a hard reset on the master branch.
# from master
# git switch -b backup
# git switch master
# git reset --hard 39c3f3b
# but I still have my backup branch with the changes.
# ------------------------------------------------------------------------

-------------------------------------------------------
Reverting Commits With -> git revert		
-------------------------------------------------------

# Reverting Commits With...Git Revert
# ********************************************************************************************************************
# So both revert and reset will undo changes from a commits, but the way that they accomplish it is different as we saw with reset.
# ------------------------------------------------------------------------
# -> Reset removes commits entirely and it moves the branch pointer backwards as if those commits never occurred, they never existed in the first place.
# ------------------------------------------------------------------------
# -> Revert does something different. It actually makes a brand new commit. And in that new commit, it undoes the changes from an earlier commit.
# -> It makes a new commit that basically says undoing changes instead of just deleting everything and deleting history, removing commits.
# -> That can be a problem if you're collaborating with other people. 
# ------------------------------------------------------------------------



# example:
# I made a commit and I want to undo it.
# git log --oneline
# git revert <commit_hash> - revert the specified commit (it will revert the specified commit)
# git revert HEAD~1 - revert the last commit (it will revert the last commit)
# -> And it opens up my editor, right? Because it generates a new commit.


# Just like when we merge, it generates a commit when we merge. Or sometimes, if it's not a fast forward.
# When there's a merge commit, we need to provide a message. So the default message is revert, make a bad commit. Now we can put other stuff in here.
# but I'm just gonna close it and let's see what happens
# git log --oneline
# ------------------------------------------------------------------------
# So now I have a new commit that undoes the changes from the previous commit.
# ------------------------------------------------------------------------
# If we go back to our editor, we can see that the two changes we made are gone.
# ------------------------------------------------------------------------
# So we still have the history preserved of that commit, but its changes have been reverted.


# So why would you do this? What's the reasoning? Why not just reset?
# ------------------------------------------------------------------------
# Well it has to do with collaboration 
# If other people have copies of that commit, if everyone else had that bad commit on their copy 
# and then I decided to get rid of it using reset, that can cause some serious problems 
# because I'm undoing history that other people have and that can be difficult to reconcile.
# ------------------------------------------------------------------------
# So instead, what we usually would do is use revert and that will make a new commit, as we've seen and I can share that new commit with everyone.
# ------------------------------------------------------------------------
# Now potentially, I might make a mistake and make a commit I want to get rid of and I haven't shared it with anyone else yet.
# Then it's fine to use reset. Nobody ever knows. They don't have it on their machines.
# --------------------------------------------------------------------------
# But as soon as collaborators have a commit, if you're trying to get rid of those changes, it's better to use revert.


# So everybody has one, two, and three, right?
# One, two, three, one, two, three. And also, my friend down here has done more work.
# She has commit four that she's worked on and I don't have that and neither does our other friend.


# I realize I wanna get rid of those two and three commits.
# I use reset and that's a problem 'cause I've already shared that with my friends.
# So it's gonna be very difficult to reconcile their code with mine because they already have those commits and they've been working on top of them.
# -> I altered the history that they already have.

# So instead what I should do is revert and make a new commit that undoes the changes from some other commit.
# And that is easy for me to share with them and for them to reconcile.

# -> sometimes reverting a commit can result in conflicts
# --------------------------------------------------------------------------
# The last thing I'll say about the revert command is that sometimes reverting a commit can result in conflicts where you need to go into the file, 
# just like any other merge conflict and figure out what you want to keep and what you want to get rid of.
# Because like our commit we just reverted was simple, it was just get rid of a line,
# but if you're reverting something from a while back and Git doesn't know what to keep and what not to keep, you have to do it yourself.
# You've gotta go into the files and resolve the conflicts and then make your commit manually. But the end result is the same.



# ---------------------------------

grand_total_m = comparison_clim_ctpa.loc[comparison_clim_ctpa['banca'] == 'Total', 'rwas_Tot_m'].values[0]
grand_total_m1 = comparison_clim_ctpa.loc[comparison_clim_ctpa['banca'] == 'Total', 'rwas_Tot_m1'].values[0]

comparison_clim_ctpa['banca_Tot_m'] = grand_total_m
comparison_clim_ctpa['banca_Tot_m1'] = grand_total_m1


# % por ctpa dentro de banca (m y m1)
comparison_clim_ctpa['pct_ctpa_cli_banca_Tot_m'] = (comparison_clim_ctpa['rwas_Tot_m'] / comparison_clim_ctpa['banca_Tot_m'])
comparison_clim_ctpa['pct_ctpa_cli_banca_Tot_m1'] = (comparison_clim_ctpa['rwas_Tot_m1'] / comparison_clim_ctpa['banca_Tot_m1'])

comparison_clim_ctpa['pct_ctpa_cli_banca_Tot_var_rel'] = (
    ((comparison_clim_ctpa['pct_ctpa_cli_banca_Tot_m'] - comparison_clim_ctpa['pct_ctpa_cli_banca_Tot_m1']) / 
     abs(comparison_clim_ctpa['pct_ctpa_cli_banca_Tot_m1']))
    )
	
	
# Totales por banca y ctpa  banca_Grand_Tot_m
comparison_cliente_final['banca_Grand_Tot_m'] = comparison_cliente_final.groupby(['banca'])['rwas_Tot_m'].transform('sum')
comparison_cliente_final['banca_Grand_Tot_m1'] = comparison_cliente_final.groupby(['banca'])['rwas_Tot_m1'].transform('sum')

# % por ctpa dentro de banca (m y m1)
comparison_cliente_final['pct_cli_banca_m'] = (comparison_cliente_final['rwas_Tot_m'] / comparison_cliente_final['banca_Grand_Tot_m'])
comparison_cliente_final['pct_cli_banca_m1'] = (comparison_cliente_final['rwas_Tot_m1'] / comparison_cliente_final['banca_Grand_Tot_m1'])

comparison_cliente_final['pct_cli_banca_var_rel'] = (
    ((comparison_cliente_final['pct_cli_banca_m'] - comparison_cliente_final['pct_cli_banca_m1']) / 
     abs(comparison_cliente_final['pct_cli_banca_m1']))
    )


# ---------------------------------

powershell -ExecutionPolicy ByPass -c "irm https://astral.sh/uv/install.ps1 | iex"


To enable shell autocompletion for uv commands, run one of the following:
    
    if (!(Test-Path -Path $PROFILE)) {
  New-Item -ItemType File -Path $PROFILE -Force
}
Add-Content -Path $PROFILE -Value '(& uv generate-shell-completion powershell) | Out-String | Invoke-Expression'


# ---------------------------------
# uv 
# ---------------------------------


# ---------------------------------
# old way
# ---------------------------------

mkdir old_way
cd old_vway
python3 -m venv .venv
source .venv/bin/activate

(.venv)
pip install flask requests

pip freeze requirements.txt

# And then after we had whatever packages we wanted installed, then we would create the project structure for this new project

touch main.py

ls -la 
.
..
.venv
main.py
requirements.txt


# And after I worked on my script here for a bit, I'd likely want to create a requirements file 
# so that I can reproduce this project and share it with other people

pip freeze requirements.txt

cat requirements.txt  ---- it lists all of our dependencies here of the packages that we installed
blinker==1.9.0
certifi==2025.4.26
....
...
Flask==3.1.0
...
..

requests==2.32.3

# dependecies after the installation of -- flask requests

# then if I pass this off to someone else, then they could recreate my project 
# by creating and activating their own virtual environment and then installing the dependencies uh from this requirements.txt file 

# ---------------------------------

where uv

uv --version

# how this compares to using UV

my desktop -- And now let's create a new project using UV

So instead of creating a new directory from scratch like I did before, 
I can instead let UV do that for me just by saying UV and we'll call this new app.

** . And just a quick side note, if you already had a project directory but 
didn't create it using uv, then you could also cd into that directory 
and just run uvit uh without the directory name and it will set up the directory you're currently using as a new application.

uv init new_app

C:\Users\aitor\OneDrive\Desktop> uv init new_app
Initialized project `new-app` at `C:\Users\aitor\OneDrive\Desktop\new_app`


# And I didn't add any additional options to it when I created this, 
but UV does have a few different project types to choose from when initializing a project

So first there is the app option and app is the default. 
So this is what was run when I just created uh my new project here. 

# This is what I use most often. It creates a simple project structure for applications, scripts, uh web servers and things like that. 

uv init new_app --app

# Uh but there is also lib 

uv init new_app --lib

and lib creates a project that is designed to be built and distributed as a Python package. 
I'd say most of us will be using the app default, but the option to create distributable Python packages is there if you're curious. 

* I have changed to show the result from the Bash
aitor@TEJADO MINGW64 ~/OneDrive/Desktop/new_app (master)
$ ls -la
total 60
drwxr-xr-x 1 aitor 197610   0 Sep 28 17:43 ./
drwxr-xr-x 1 aitor 197610   0 Sep 28 17:43 ../
drwxr-xr-x 1 aitor 197610   0 Sep 28 17:48 .git/
-rw-r--r-- 1 aitor 197610 109 Sep 28 17:43 .gitignore
-rw-r--r-- 1 aitor 197610   5 Sep 28 17:43 .python-version
-rw-r--r-- 1 aitor 197610   0 Sep 28 17:43 README.md
-rw-r--r-- 1 aitor 197610  85 Sep 28 17:43 main.py
-rw-r--r-- 1 aitor 197610 153 Sep 28 17:43 pyproject.toml

# what UV created for us with the default init for an application.

# So if I list all the files here, so first we have a git directory and a git ignore file. 
So UV automatically initializes a git repository for us, which is nice because most of us will want to track our code within version control anyway.

# the git ignore file has some common python specific files that we typically don't want to track in git 
like cache files and the virtual environment. 

# python version file which contains the python version this project is configured to use. 
UV uses this to ensure that we're working with a consistent Python version as we're building this application.
Uh right now it probably contains the version of Python that we have installed on our system. Uh but we can change this if needed

# then we have a readme file uh which is currently empty. Uh but this is where you'd typically add documentation about your project.

# this main.py file here is a simple starter Python file for our application. UV creates this as a placeholder where we can begin writing our code. 

# finally we have the pyproject.toml file uh which is a modern way to configure Python projects.

--- go to VSCode to see everything

code.


how to see hidden folders in vscode
Check Explorer Visibility Settings in VS Code
File → Preferences → Settings
Search for files.exclude
X .git
now I can see .git folder


or Review or Edit the Exclude Rules -- "Edit in settings.json"
"files.exclude": {
  "**/.git": true,
  "**/.venv": true,
  "**/node_modules": true
}
transform in

"files.exclude": {
  "**/.git": false,
  "**/.venv": false
}

continue in VSCode

pyproject.toml file -- 

[project]
name = "new-app"
version = "0.1.0"
description = "Add your description here"
readme = "README.md"
requires-python = ">=3.12"
dependencies = []

# this has some basic information about our application. And at the bottom we can see it's listing our dependencies. 
# Right now it's an empty list because we haven't added any packages uh that we're going to use for this application yet

# Now, this is normally where we'd create and activate our virtual environment, but we don't need to do that here.
UV will handle that for us automatically the first time that we run a command that actually needs 

so let's add those packages in uh that we used in our last example
-- install flash and request like we did before, but instead of pip, I'm going to use uv add

aitor@TEJADO MINGW64 ~/OneDrive/Desktop/new_app (master)
$ uv add flash requests

Using CPython 3.12.10 interpreter at: C:\Users\aitor\AppData\Local\Microsoft\WindowsApps\PythonSoftwareFoundation.Python.3.12_qbz5n2kfra8p0\python.exe
Creating virtual environment at: .venv
Resolved 7 packages in 255ms
Prepared 6 packages in 138ms
Installed 6 packages in 36ms
 + certifi==2025.8.3
 + charset-normalizer==3.4.3
 + flash==1.0.3
 + idna==3.10
 + requests==2.32.5
 + urllib3==2.5.0
 
# also if I look towards the top here we can see that it tells us the Python interpreter that it's using 
-- Using CPython 3.12.10 interpreter at: C:\Users\aitor\AppData\Local\Microsoft\WindowsApps\PythonSoftwareFoundation.Python.3.12_qbz5n2kfra8p0\python.exe

# and also detected that we need a virtual environment. So it created this .venv directory right here for us in our project 
and then it installs flask and request into that environment 
-- Creating virtual environment at: .venv

# and there are a couple other things that it did here as well.
-- that it also updated our pyproject.toml here to list flask and request as dependencies

pyproject.toml

[project]
name = "new-app"
version = "0.1.0"
description = "Add your description here"
readme = "README.md"
requires-python = ">=3.12"
dependencies = [
    "flask>=3.1.2",
    "requests>=2.32.5",
]

# it created this uv.lock file for us

this lock file records the exact versions of all the packages installed including sub dependencies.
this ensures that your environment is perfectly reproducible 
and it does all of that without us creating or activating any virtual environments. 

(helps to uh prevent the classic problem of it working on one machine and not working on another because of some small discrepancy somewhere.)

nice feature here for visualizing and understanding our dependencies.

uv tree

aitor@TEJADO MINGW64 ~/OneDrive/Desktop/new_app (master)
$ uv tree
Resolved 14 packages in 0.88ms
new-app v0.1.0
├── flask v3.1.2
│   ├── blinker v1.9.0
│   ├── click v8.3.0
│   │   └── colorama v0.4.6
│   ├── itsdangerous v2.2.0
│   ├── jinja2 v3.1.6
│   │   └── markupsafe v3.0.3
│   ├── markupsafe v3.0.3
│   └── werkzeug v3.1.3
│       └── markupsafe v3.0.3
└── requests v2.32.5
    ├── certifi v2025.8.3
    ├── charset-normalizer v3.4.3
    ├── idna v3.10
    └── urllib3 v2.5.0

# - o now let's say that we work on our application for a while and now we want to run it.
How would we do that from the command line if that virtual environment isn't activated?

# So from an IDE, this should be fairly simple. let me open up that main.py file here within VS Code. 

# So within most IDE, you should have an easy way to find virtual environments within your current project. 
Mine automatically selects virtual environments inside of my projects if they exist. 

but we actually open this project before that environment was created. 
So to select it, I just have to navigate down here to the bottom right.
we can see that it's using this uh 3.12 here
I'm just going to have it select this virtual environment here within my directory.

make sure this works
let's print out the Python executable that's executing our script


def main():
    print("Hello from new-app!")


if __name__ == "__main__":
    main()
	
------------------------------	
	
import sys

def main():
    print(sys.executable)


if __name__ == "__main__":
    main()
	

-----------------------------------
-- we found a problem here -- the environment was not activated
so it was taking the global python installation to execute

-----------------------------------

First, check what you're seeing:

Depending on your operating system:

Linux/macOS: Virtual environments normally have:

.venv/
  bin/
  lib/
  pyvenv.cfg


Windows:

.venv/
  Scripts/
  Lib/
  pyvenv.cfg


----- If you're on Windows, bin/ will not exist—Scripts/ is used instead.

---------------
solution:


Then, activate it:

Unix/macOS:

source .venv/bin/activate


Windows:

.venv\Scripts\Activate.ps1


# si uso git bash --- para activar el environment
source .venv/Scripts/activate

--------------------
(new-app)
aitor@TEJADO MINGW64 ~/OneDrive/Desktop/new_app (master)
$ python main.py
C:\Users\aitor\OneDrive\Desktop\new_app\.venv\Scripts\python.exe

(new-app) PS C:\Users\aitor\OneDrive\Desktop\new_app> python main.py
C:\Users\aitor\OneDrive\Desktop\new_app\.venv\Scripts\python.exe

--------------------

we are deactivate our enviromnet
-- we don't have any virtual environments active right now.
but uv runs the code and automatically uses that virtual environment that it created earlier.

aitor@TEJADO MINGW64 ~/OneDrive/Desktop/new_app (master)
$ deactivate
aitor@TEJADO MINGW64 ~/OneDrive/Desktop/new_app (master)
$ uv run main.py
C:\Users\aitor\OneDrive\Desktop\new_app\.venv\Scripts\python.exe


(new-app) PS C:\Users\aitor\OneDrive\Desktop\new_app> deactivate

PS C:\Users\aitor\OneDrive\Desktop\new_app> uv run main.py
C:\Users\aitor\OneDrive\Desktop\new_app\.venv\Scripts\python.exe

--------------------

--So I'll go ahead and just delete that completely from my project. 
So I will uh say remove that virtual environment

aitor@TEJADO MINGW64 ~/OneDrive/Desktop/new_app (master)
$ rm -rf .venv

-now we can see that there is no virtual environment here 

-- normally this would screw us up.
Uh we'd have to go in and create this environment again. 
activate it and then install the packages to run our code 
and then finally be able to run our code.

-- nowBut all of the information that we need to run this code 
is in our pyproject.toml and uv.lock files

So with UV, if I just try to run this again with 

uv run main.py
if I run this, then we can see that it runs that just fine.

aitor@TEJADO MINGW64 ~/OneDrive/Desktop/new_app (master)
$ uv run main.py
Using CPython 3.12.10 interpreter at: C:\Users\aitor\AppData\Local\Microsoft\WindowsApps\PythonSoftwareFoundation.Python.3.12_qbz5n2kfra8p0\python.exe
Creating virtual environment at: .venv
Installed 13 packages in 46ms
C:\Users\aitor\OneDrive\Desktop\new_app\.venv\Scripts\python.exe



And what it did was --- it saw that we didn't have a virtual environment. 
--- So it created that for us. Then it installed all of those packages very quickly. 
And then it ran the code for us, all with one command

---------------------
And we don't even need to run that main.py file to get it to create our environment and install those dependencies. 
so if I were to pass this off to someone and they wanted to get their environment ready without running the application, 
then they could simply use 

uv sync

example: 
- remove our environment again : 
rm -rf .venv

And now if I pass this off to someone and they have this on their machine, 
then they can simply run UV sync. And when they run that,
we can see that it recreated the exact same environment using the uv.lock file. 

-- in someone computer

uv sync

aitor@TEJADO MINGW64 ~/OneDrive/Desktop/new_app (master)
$ uv sync
Using CPython 3.12.10 interpreter at: C:\Users\aitor\AppData\Local\Microsoft\WindowsApps\PythonSoftwareFoundation.Python.3.12_qbz5n2kfra8p0\python.exe
Creating virtual environment at: .venv
Resolved 14 packages in 0.94ms
Installed 13 packages in 44ms
 + blinker==1.9.0
 + certifi==2025.8.3
 + charset-normalizer==3.4.3
 + click==8.3.0
 + colorama==0.4.6
 + flask==3.1.2
 + idna==3.10
 + itsdangerous==2.2.0
 + jinja2==3.1.6
 + markupsafe==3.0.3
 + requests==2.32.5
 + urllib3==2.5.0
 + werkzeug==3.1.3
 
And now if we wanted to --- remove a dependency, 
uv remove flask.

aitor@TEJADO MINGW64 ~/OneDrive/Desktop/new_app (master)
$ uv remove flask
Resolved 6 packages in 133ms
Uninstalled 8 packages in 27ms
 - blinker==1.9.0
 - click==8.3.0
 - colorama==0.4.6
 - flask==3.1.2
 - itsdangerous==2.2.0
 - jinja2==3.1.6
 - markupsafe==3.0.3
 - werkzeug==3.1.3

And if I run that, it takes that off. 
And that would 
--- remove that package and 
--- update the pyproject and 
--- lock file. 

And then they could simply send that back to me without their virtual environment. 
and I could run UV sync and get synced up with those dependencies

-- instead of running five to six different commands and having to understand virtual environments
we've got a much more streamlined process that does all the complexity be behind the scenes


biggest advantages that you'll notice with UV -- especially over time, is its smart global caching system
-- so this means that if we have 10 different projects that all use the same version of Flask,
UV only stores that Flask version and its dependencies once on our disk, which saves a lot of space.

-- So your environments still remain completely isolated from each other. 
So there's no risk of conflicts there. 
but you get the dispace savings and major speed improvements when installing packages that you've used before

noticeable when recreating environments or setting up new projects with familiar dependencies because with pip and venv different virtual environments for different projects might contain duplicate copies of the same packages

save disc space but you also save on download times

-- UV provides a UV pip subcommand that acts as a direct faster replacement for pip itself
(gradual transition)

-- go back to our old_way directory

cd old_way

ls -la 
.
..
.venv
main.py
requirements.txt

So in here we haven't set this up with UV. 
If I look at the files in this directory then we should only have our Python script and our requirements.txt file. 
So if I wanted to work on this, we could activate the environment and then use pip to install a package using pip.

But UV has a pip command that behaves the same as pip. 
And if you have a virtual environment in your project already, then it will find that for you. 

-- add numpy for example
uv pip install numpy


uv pip list 
then we can see that now we have flask request and we also have numpy 

-- since it's just doing what pip would do, -- it's not creating that pi project or lock file in the background.

So if I wanted this requirements.txt file to be up to date with the packages that we just installed, 
then we'd have to do a uv pip freeze to overwrite that. 

-- if I wanted to migrate this project here over to using UV's workflow instead of pips, then I could just say 
uv init

And that will create the project structure that we saw before. 
And then I'd have to add those packages from the requirements.txt file.

And now I want to add those packages from the requirements.txt file. 
uv add -r requirements.txt

And if I look at the pyproject file then we can see that now all of those are listed in our dependencies.
So at that point if you wanted to move forward only using uv then you could delete that requirements.txt file and rely solely on your pi project and lock files. 

-------------------------------

go back to our new-app project (with uv from scratch)

-- another really cool feature of UV is that 
it can replace pipx for installing Pythonbased command line tools.

if you don't know what Pip X does, it basically allows you to install Python command line tools that you can use anywhere on your system and not just in a specific project

(so llinters, formatterers, things like that. Uh those are things that you'll likely just want to install once and use across multiple different projects as opposed to installing them in every project individually.)
And we can also do this with UV

-- let's say that we wanted to install Ruff, which is a popular Python linter 
you might install this with pipx

-- uv tool install ruff

aitor@TEJADO MINGW64 ~/OneDrive/Desktop/new_app (master)
$ uv tool install ruff
Resolved 1 package in 243ms
Prepared 1 package in 664ms
Installed 1 package in 10ms
 + ruff==0.13.2
Installed 1 executable: ruff


And what this does is it installs rough in an isolated environment but makes it available on your path.


So let's confirm that that's installed and accessible from anywhere -- which ruff
And we can see that it did install it here in my uh local bin directory of my home folder. So that should be available anywhere on the system

aitor@TEJADO MINGW64 ~/OneDrive/Desktop/new_app (master)
$ which ruff
/c/Users/aitor/.local/bin/ruff

uninstall it

aitor@TEJADO MINGW64 ~/OneDrive/Desktop/new_app (master)
$ uv tool uninstall ruff
Uninstalled 1 executable: ruff

uv tool list

aitor@TEJADO MINGW64 ~/OneDrive/Desktop/new_app (master)
$ uv tool list
ruff v0.13.2
- ruff

-- we can upgrade those individually if you want, but most likely you'd probably want to update them all at once. 
uv tool upgrade --all

------------------

running tools without installing them

- Now, one really cool thing about UV is that we don't even need to install these tools permanently on our system. in order to use them

if you just want to test out a tool or use it a few times for a specific task without permanently installing it, 
then we can do that by saying 

uv tool run xxx

aitor@TEJADO MINGW64 ~/OneDrive/Desktop/new_app (master)
$ uv tool run ruff check
Installed 1 package in 8ms
All checks passed!

-- And we can see that that works just like it did before.
But if I search for rough on my system, then we can see that it's not installed. 

which ruff
ruff not found

So that UV tool run command installs it in a temporary environment, runs it, and then cleans it up afterwards, which is super useful

shortcut --- uvx
uv tool run ruff check
uvx ruff check (same)



So, I really like UV's tool integration here. Uh, it's taking all of these things that used to be separate tools like pip, pip x, and virtual environments and making them feel naturally like they belonged as a single tool to begin with.

And there's even more that UV can do that we haven't covered. So, it has ways of managing different Python versions, has commands for building and uploading your own Python packages to Pippi, uh, and even has some features designed to help, uh, build optimized Docker containers