-------------------------------------------------------

git add <file1> <file2>
git add .
git rm --cached <file> -> (just first time - forgot about this)
git clean -f filename.txt -> This removes the untracked file named filename.txt.
git mv old_name.txt new_name.txt -> rename a file that is already in the staging area

- imagine we have already done our first commit

git restore file.txt -> discard/remove the changes in the working directory - This will replace your local file.txt with the version from the staging area (or from the last commit if it wasn’t staged).
git restore --staged <file> -> (it will remove the file from the staging area, but not delete it from the working directory)
git reset --soft HEAD~1 -> (undo last commit, but keep changes in the staging area ready to recommit)
	- Typical use case : When you realize your last commit message was wrong or you forgot to include something and want to amend it.
	
git reset HEAD -> If you only want to unstage files but keep your edits

git reset --hard <commit_hash> 
	Moves HEAD and the branch pointer to the given <commit_hash>.
	Resets the staging area and working directory to match that commit.

	All uncommitted changes (both staged and unstaged) are lost.
	It completely discards work that came after the target commit.

	- Typical use case : When you want to completely roll back to an earlier state and don’t care about losing newer changes.


git commit -> (comit all changes in the staging area) (it will open the default editor to write a commit message)
git commit -m "commit message"
git add . && git commit -m "your commit message"
git commit -a -m "commit message" -> (add + commit)  from working directory to staging area and then commit (-a: Automatically stages all modified and deleted tracked files (but not new/untracked files).)

git log --oneline -> show the commit history in one line (it will show the commit hash and commit message) (shorter version of git log)

git commit --amend -m "new commit message" -> you made a commit / you realized you forgot to add a file / you can use git commit --amend to modify the last commit and add the file to it

-------------------------------------------------------
- .gitignore
-------------------------------------------------------

.gitignore - file that contains a list of files and directories to be ignored by git (not tracked)
 
touch .gitignore -> create a new .gitignore file in the current directory
echo "file.txt" >> .gitignore -> add file.txt to the .gitignore file (it will ignore the file.txt in the repository)
echo "folderName/" >> .gitignore -> add folderName/ to the .gitignore file (it will ignore the folderName/ in the repository)
echo "*.log" >> .gitignore - add *.log to the .gitignore file (it will ignore all log files in the repository)

save gitignore file
git add .gitignore -> add the .gitignore file to the staging area (index) (it will be included in the next commit)
git commit -m "add .gitignore file" -> commit the .gitignore file (we are committing this to tell git to ignore the files and directories in the repository)

example:

create a secrets.txt - API_KEY=1234567890abcdef (example API key)
- we have included this file in the .gitignore file, and we have committed the .gitignore file. 
- the next time we modify the file (secrets.txt) once again and then we run git status, it will show that the secrets.txt file is ignored by git (it will not be tracked by git)
- git status will show - on branch master nothing to commit, working tree clean (it will not show the secrets.txt file in the status)

git status --ignored  -> show the status of the repository including ignored files (it will show the ignored files in the status)

git check-ignore -v file.txt -> check if a file is ignored by git (it will show the .gitignore file that is ignoring the file)
git check-ignore -v folderName/ -> check if a folder is ignored by git (it will show the .gitignore file that is ignoring the folder)
git check-ignore -v .gitignore -> check if the .gitignore file is ignored by git (it will show the .gitignore file that is ignoring the file)

git ls-files --others --ignored --exclude-standard -> list all ignored files in the repository (it will show the ignored files in the repository)

gitignore.io - website that generates .gitignore files for different programming languages and frameworks (it is created by us)
- https://www.toptal.com/developers/gitignore
- https://www.gitignore.io/api/ (API for generating .gitignore files)

--------------------------------------------------------
- branches
--------------------------------------------------------

whatever we do in one branch will not affect the other branches (it is a copy of the repository) although we can decide to then combine branches.
branches are used to work on different features, bug fixes, or experiments in the same repository (it is a copy of the repository)

default branch - master (MASTER) - people use it as main branch of the repository.(source of truth)
When you make a new Git repository, when we run git init, -> automatically the branch that we start on is called master.

GitHub changed the default branch name from master to main. (MAIN is the new default branch name) // Git the default branch name is still master

--------------------------------------------------------
- HEAD
--------------------------------------------------------

HEAD - points to the current branch, the current location in our repo (where we are currently working)
Branches - like bookmarks in a book. At any given point in time only one of those spots can be open, right? We can't have the book open to multiple pages. So, that is what HEAD refers to.
when I switch to another brach, HEAD points to that.
I create a new commit in the new branch - The HEAD is also pointing to that new commit.

git switch <branch> -> switch to the specified branch (it will move HEAD to the tip of the specified branch) (ex: git switch bugfix)

git branch -> list all branches in the repository (it will show the current branch with an asterisk)
git branch -a -> list all branches in the repository (it will show the current branch with an asterisk and all remote branches)
git branch -v -> list all branches in the repository with details (it will show the current branch with an asterisk and details)

--------------------------------------------------------
- Creating & Switching Branches
--------------------------------------------------------

git branch <branch_name> -> create a new branch based upon the current HEAD (it will not switch to the new branch) 
((HEAD -> master, Bugfix) -> they are both pointing to the same commit. (same page is bookmarked with two different bookmarks))

git switch -b <branch_name> -> create a new branch and switch to it (it will move HEAD to the tip of the new branch)
git switch -c <branch_name> -> create a new branch and switch to it (it will move HEAD to the tip of the new branch) (it is the same as git switch -b)

the same ones with --> git checkout, but it is more intuitive and easier to remember git switch
git checkout <branch_name> -> So this command git checkout. existed for a long time. It still exists in Gits, -> and it does a lot more than just switching branches.
So git switch was introduced. It's newer. (git switch <branch_name>)

--------------------------------------------------------
- Switching Branches With Unstaged Changes? - CONFLICT EXAMPLE
--------------------------------------------------------

I try to switch branches with a file that has unstaged changes in source and already exists in the target branch.
--------------------------------------------------------
If I'm on a branch and I have some work that is not currently committed, (we have modified files in the working directory)
but we have nor added then to the staging area nor committed them yet. - you can see with git status
--------------------------------------------------------
If I try to switch branches, Git will not let me do that. -> I get an error. - WARNING
-> Your local changes to the following files would be overwritten by checkout. 
It's telling me that the work I have done right now that I have not yet committed, which is right here, if I try and switch to a different branch -> it's gonna be lost because it's not committed.
The other branch doesn't know about it. 
--------------------------------------------------------
So it says, "Please commit your changes or stash them." (We will learn more about stashing in just a couple of sections from now.)
--------------------------------------------------------
For now, our only option is to commit our work or just delete it I guess, and not make those changes. 
So I am gonna commit that. And now I can switch. So I can do the same command to switch to empty playlist. No complaints.

--------------------------------------------------------
- Switching Branches With Unstaged Changes? - WITHOUT CONFLICT EXAMPLE
--------------------------------------------------------

Conflict example exercise
--------------------------------------------------------
(same file in two branches) - So if I have a file that is in conflict, and I try to switch branches, Git will not let me do that.
we had changes that were in conflict, right when I tried to switch branches, we were working on the same file, this playlist.txt file and they were in conflict.
And so Git yelled at me and said, "Hey, I don't know what to do." (We'll learn more about conflicts when we get to merging but sometimes that's not an issue at all.)
--------------------------------------------------------
example of NEW FILE WITHOUT ANY CONFLICT -> the file will just follow you to the other branch.
--------------------------------------------------------
en oldies
git switch -c chicken
And on this chicken branch, I'm gonna make a -> new file entirely called chickens.txt.(this file only exists on this branch)
so I have this new file no other branch has but I haven't added or committed that file.
--------------------------------------------------------
git switch oldies
Previously at the beginning of this video we saw that Git yelled at me when I tried to switch and it says, 
"You can't switch. You have changes that are gonna be overwritten that are in conflict. 
We don't know what to do. Please stash or commit them."
--------------------------------------------------------
-> But this is going to be different because NO OTHER BRANCH HAS THIS FILE. There's no way that it's in conflict with anything.
-> So what actually will happen is THIS FILE IS GOING TO COME WITH ME. (I'm now on the oldies branch and I still have chickens.txt.)
git status - You haven't made a commit with it anywhere. (Untracked file chickens.txt)
You haven't made a commit with it anywhere. It's just gonna follow you to every branch you go to."
--------------------------------------------------------
So for now, I'm just gonna recommend we always add and commit changes before we switch branches so that we can avoid this.
- When you switch branches, sometimes, if you have unstaged changes, they will come with you.
- Other times if they're in conflict, Git will yell at you, so just know that.
--------------------------------------------------------

--------------------------------------------------------
- Deleting Branches -> git branch -d/-D <branch_name>
--------------------------------------------------------

RULE N1 - You can only delete branches that are not currently checked out. (You can't delete the branch you're on.)
--------------------------------------------------------
git branch -d <branch_name> - delete the specified branch (it will delete the branch only if it is fully merged)
error: The branch 'branch_name' is not fully merged. (it will not delete the branch if it is not fully merged)
we will need to merge the branch first before we can delete it.
--------------------------------------------------------
-> allow deleting the branch irrespective of its merge status:
git branch -D <branch_name> -> delete the specified branch (it will delete the branch even if it is not fully merged)
git branch --delete --force <branch_name> -> delete the specified branch (it will delete the branch even if it is not fully merged)
--------------------------------------------------------
I want to delete - deleteMEbranch --> (MOVE TO) git switch master --> git branch -D deleteMEbranch - OK

--------------------------------------------------------
- Renaming Branches -> git branch -m <new_branch_name>
--------------------------------------------------------

RULE N1 - you have to be on the branch you want to rename
--------------------------------------------------------
git branch -m <new_branch_name> -> rename the current branch to the specified name
git branch -m <old_branch_name> <new_branch_name> -> rename the specified branch to the specified name
--------------------------------------------------------
-m --> --move (move/rename) a branch and the corresponding reflog
-M --> --move --force (move/rename) a branch and the corresponding reflog (force rename)
--------------------------------------------------------
in recentest-music branch --> git branch -m 2000s

--------------------------------------------------------
- How Git Stores HEAD & Branches?
--------------------------------------------------------

look at that .git directory and I'll show you proof of HEAD, how it works, 
the fact that it's just referencing a branch and that each branch reference is referencing a commit.
-> Important to understand Detached HEAD and how that works.
--------------------------------------------------------
git log
commit 93edf2b0c4a3d1e5c7 (HEAD -> master) - commit hash (it is the unique identifier for the commit)
ls -a
.git - hidden directory that contains all the information about the repository (it is created by git)
cd .git
ls
HEAD - file that contains the current branch (it is a pointer to the current branch)
cat HEAD
ref: refs/heads/master - it is a pointer to the master branch (it is a reference to the master branch)
back out and switch to another branch- in oldies branch
cat .git/HEAD
ref: refs/heads/oldies - it is a pointer to the oldies branch (it is a reference to the oldies branch)
--------------------------------------------------------
refs/heads/master OR refs/heads/oldies - they are references to the branches (they are pointers to the branches) 
-> BUT they actually references to a particular commit. (commit hash)
--------------------------------------------------------
If I open the folder refs/heads, I can see all the branches in my repository. (one file for each branch)
and if I open the file master, I can see the commit hash that it points to. -(93edf2b0c4a3d1e5c7) - (the bookmark)
and if I open the file oldies, I can see the commit hash that it points to.

--------------------------------------------------------
- Merging Branches -> git merge <branch>
--------------------------------------------------------

-> We merge branches, not specific commits, so we don't pick one commit and the second commit and join them together.
-> we always merge based on the current HEAD branch. We merge to where we are to where HEAD is.

example:
I have 2 branches, a master branch and a bugfix branch.
And on this bugfix branch, you can see down here I have some commits
I've made a new branch from master, and I've added 2 commits as I'm fixing this bug, and it's now time for me to merge that work into master.

-------------------------------------------------------
the workflow here is:
1. first switch or check out the branch that we want to merge the changes into. (We need to move over to the receiving branch. I need to switch to master.)
       git switch master - switch to the master branch (it will move over to the receiving branch)
2. then we run the merge command, and we specify the branch that we want to merge in. (git merge bugfix)
       git merge <branch> -> merge the branch into the current branch (it will merge the changes from the specified branch into the current branch)
       git merge <branch> --no-ff -> merge the branch into the current branch with a no fast forward (it will create a new commit even if the merge can be done with a fast forward)
       git merge <branch> --ff-only -> merge the branch into the current branch with a fast forward only (it will only merge if the merge can be done with a fast forward)
       git merge <branch> --squash -> merge the branch into the current branch with a squash (it will combine all the commits from the specified branch into a single commit)
       git merge <branch> --no-commit -> merge the branch into the current branch without committing (it will not create a new commit)
       git merge <branch> --abort -> abort the merge (it will cancel the merge and return to the previous state) **** (when the message of merge conflicts appear)
       git merge <branch> --continue -> continue the merge (it will continue the merge after resolving conflicts)
       git merge <branch> --edit -> edit the commit message for the merge commit (it will open the default editor to write a new commit message)
-------------------------------------------------------
We had master, we branched off to bugfix and did 2 commits. Now all that we did when we merged was catch up. We moved master up to that same commit.
-> So now master has all that history, it has the work that it had from before, but also the work from bugfix.
-------------------------------------------------------
-> This is called a --> fast forward merge <-- because that's all we had to do for this branch to catch up.
In our case There wasn't additional work on the master branch. But sometimes that will be the case.
So there'll be additional commits over here that don't exist on bugfix and that is trickier to merge and that's what we're gonna spend some time talking about.

-------------------------------------------------------
Performing A Fast Forward Merge (simpler merge case - no conflicts)
-------------------------------------------------------

Remember that this is a special case of a merge. Not all merges work this way
steps:
1. first switch or check out the branch that we want to merge the changes into. (We need to move over to the receiving branch. I need to switch to master.)(git switch master)
2. then we run the merge command, and we specify the branch that we want to merge in. (git merge bugfix)

git branch -v -> show the list of branches and the last commit on each branch

git switch master
git merge oldies -> 3 additional commits to merge on master

git log
we will see that the master branch has all the commits from the oldies branch. (HEAD -> master, oldies)

*** we still have the oldies branch. (it is not deleted) *** 
(and they are both pointing to the same commit but they are not synchronized) forever
so I can go to oldies and make more commits and all that stuff will not exist on master.

-------------------------------------------------------
Merge Commits - (non-fast forward merge)
-------------------------------------------------------

you made changes in your branch and you want to merge it back into the master branch.
BUT - somebody's already done some work on the master branch - there is a 1 or 10 commits in master I do not have in my branch
-> Now there's new information that I don't have on bugfix and there's information on bugfix that master does not have.

We use the exact same commands, but Git may not be able to do it automatically for us. 
It depends on the particulars of our commits and if there's conflicting information. What if we both modified line 59?
Which one wins when there's a conflict? - we will talk about conflicts later on.

rather than performing a fast forward merge, -> Git will perform a MERGE COMMIT.
-------------------------------------------------------
Basically git just makes a commit for us on the branch that we're merging into, the recipient branch.
It makes a new commit for us and it will prompt us to include a message.
-> This commit will have two parents, one from the branch that we're merging into and one from the branch that we're merging in.

example:
master 2 commits that ABBA does not - ABBA 2 commits that master does not (merge on master)
git switch master
git merge ABBA
the default editor will be open (VSCode) - suggests as a message - close it and will perform the merge
-------------------------------------------------------
it says merge made by the recursive strategy.
git log
we will see the initial 2 master commits, then ABBA 2 commits, then master 2 commits, and the merge commit.

-------------------------------------------------------
Merge Conflicts! - Conflicting changes
-------------------------------------------------------

sometimes Git need our help - doesn't know how to automatically merge situations.
- in one branch a file modified, in another the same file deleted...
- same line in a file edited in both branches with different content...

message:
CONFLICT (content): Merge conflict in file.txt
Automatic merge failed; fix conflicts and then commit the result.

Resolving MERGE conflicts - multi-step process:
-------------------------------------------------------
0. Git tells us there's conflicts  
1. Open un the file(s) with merge conflicts
2. Edit the file(s) to remove the conflicts. Decide which branch´s content to keep in each conflict. Or keep the content from both branches.
3. Remove the conflict markers (the <<<<<<<, =======, and >>>>>>> lines) in the document.
4. Save the file(s).
5. Add the file(s) to the staging area (git add <file>)
6. Commit the changes (git commit -m "message")
7. Push the changes to the remote repository (git push)

So the files where there are conflicts are actually decorated. They have new content to indicate where there are conflicts.
So when we open up a file, we'll see this weird stuff in there, head and then a branch name.

So what these markers indicate is
------------------------------------------------------- 
- what content came from my head branch, the branch I'm on, the recipient branch I'm trying to merge into.
(So this is what I had in this diagram on my, let's say the master branch. This is the change I made.)
And that's indicated by the less than the little arrow head (<<<<<<). 
And then the equal sign. ==============
Behind equal signs:
this is from the bug fix branch that I'm trying to merge in.
------------------------------------------------------- 
So it's my job now to delete or keep both, figure out which part I want, which part I don't want. It's totally up to me.

I resolve it and then I get rid of these conflict markers, these symbols, 
and then I save the file and then I go back and add and commit the changes.

a typical approach example:
------------------------------------------------------- 
2 branches with potential differences or possible merge conflicts (A and B)
we want in A the info of B. Create a 3rd branch from A called C (combo)
git switch -c combo
git merge B

CONFLICT - resolve it choose what you want (<<<<<<<, =======, and >>>>>>> lines)

options to choose when solving conflicts in VSCode:
accept current change | accept incoming change | accept both changes | compare

Sometimes when you're resolving conflicts, you may need to add additional code or a comment to explain something.

save this file/s
git add <file/s in conflict>
git commit -m "resolve conflicts" - (it will create a new commit with the specified message)

------------------------------------------------------- 
Show the differences between branches -> git diff
------------------------------------------------------- 

git diff -> show the differences between the current branch and the specified branch

It doesn't do anything to the repository, doesn't impact anything (purely an informative command.)

So in a given repository, there are many situations where we might wanna know 
- what changed between the last commits and our working directory.
- What's changed between the staging area and the working directory?
- What's changed between two branches or two different files over a certain number of commits?
- What's changed between what we have locally versus what's on GitHub?

git diff  -> current content of your files (working directory) with the last version that was added to the staging area (git add)
git diff HEAD  -> Working directory vs Last commit (since HEAD) (includes both staged and unstaged changes)
git diff --staged or --cached  -> Staging area vs Last commit

git diff <file>
git diff HEAD [<file>]
git diff --staged [<file>]

Comparing Changes Across Branches - [THE ORDER MATTERS]
------------------------------------------------------- 
git diff <branch1> <branch2> -> diffs bwn 2 specified branches 
git diff <branch1> <branch2> -- <file> -> sdiffs bwn 2 specified branches for the spec file
git diff <branch1> -- <file> -> diffs bwn the specified branch and the spec file
git diff <branch1> <branch2> -- <file1> <file2> -> diffs bwn 2 specified branches spec files

Comparing Changes Across Commits - INTERESTING command - [THE ORDER MATTERS]
------------------------------------------------------- 
git diff <commit1> <commit2> -> show the differences between the 2 specified commits)
- a past commit (not necessarily the last commit (HEAD))
------------------------------------------------------- 
-> you must specify the commit hash
------------------------------------------------------- 
git diff <commit1> <commit2> -- <file> -> diffs bwn 2 specified commits for the spec file
git diff <commit1> -- <file> -> diffs bwn the spec commit and the spec file 
git diff <commit1> <commit2> -- <file1> <file2> -> diffs bwn 2 specified commits spec files

git diff <commit> <branch> -> diffs bwn the specified commit and the specified branch
git diff <branch> <commit> -> diffs bwn the specified branch and the specified commit
git diff <commit> <branch> <file> -> diffs bwn the spec commit and the spec branch for file 
git diff <branch> <commit> <file> -> diffs bwn the spec branch and the spec commit for file 

------------------------------------------------------- 
A guide to reading Diffs
-------------------------------------------------------

last commit: red orange yellow green blue purple
new changes: red orange yellow green blue indigo violet

what we compare is what it is in file b/ regarding file a/
-------------------------------------------------------
diff --git a/rainbow.txt b/rainbow.txt ----- files to compare a/ and b/
index 72d1d5a..f2c8117 100644  ------------- metadata about the files
--- a/rainbow.txt			   ------------- original file being compared.
+++ b/rainbow.txt			   ------------- indicates the modified file.
@@ -3,4 +3,5 @@ orange
 yellow
 green
 blue
-purple						   ------------- removed from the original file.
+indigo						   ------------- added to the original file.
+violet						   ------------- added to the original file.

-------------------------------------------------------

@@ -3,4 +3,5 @@ orange
# Lines from the original file (starting from line 3, showing 4 lines).
# Lines from the modified file (starting from line 3, showing 5 lines).
# orange: This line indicates the context around where the changes occur.
